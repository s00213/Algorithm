using System.Diagnostics.Metrics;

namespace _08_1._HashTable
{
    internal class Program
    {
        // 2. 해싱과 해시함수에 대한 조사
        // (해시의 원리, 해싱함수의 효율 등)

        // * 해싱
        // : 데이터를 담을 테이블을 미리 크게 확보해 놓은 후 입력받은 데이터를 해시하여 
        //   테이블 내의 주소를 계산하고 이 주소에 데이터를 담는 것

        // * 해싱함수의 효율
        // : 해시를 통해 데이터가 담길 주소값을 얻는 것은 상수 시간 내에 결정되기 때문에,
        //   테이블의 크기가 얼마가 되든 성능은 전혀 달라지지 않습니다.해시 테이블에게는 
        //   ‘탐색’이라는 단어가 무색할 정도로, 주소(인덱스) 를 구하는 방법만 다르다 뿐이지 
        //   오히려 배열과 다름없는 요소에 대한 접근 속도를 자랑함
        //   다만, 해시 테이블은 데이터가 입력되지 않은 여유 공간이 많아야 제 성능을 유지할 수 있음

        // key를 index로 해싱할 떄 * 나눗셈법과 * 자릿수 접기를 사용함
        // * 나눗셈법
        // : 입력 값을 테이블의 크기로 나누고, 그 ‘나머지’를 테이블의 주소로 사용함
        // : 주소 = 입력 값 % 테이블의 크기
        // -> 나눗셈법은 0부터 «-1 사이의 주소를 반환함을 보장함

        // 단순한 알고리즘인 나눗셈법의 충돌이나 클러스터링의 문제를 완벽하게 제거할 수 있는 알고리즘은 없으나,
        // 문제를 일으킬 가능성을 줄인 알고리즘인 자릿수 접기가 있음

        // * 자릿수 접기
        // : 문자열을 키로 사용하는 해시 테이블에 특히 잘 어울리는 알고리즘


        // 3. 해시테이블의 충돌과 충돌해결방안
        // * 충돌
        // : 서로 다른 입력 값에 대해 동일한 해시 값
        // -> 해시 테이블 내의 동일한 주소를 반환할 가능성이 높음

        // * 나눗셈법의 한계
        // : 서로 다른 입력 값에 대해 동일한 해시 값
        // -> 해시 테이블 내의 동일한 주소를 반환할 가능성이 높음
        // : 똑같은 해시 값이 아니더라도 해시테이블 내의 일부 지역의 주소들을 집중적으로 반환하는 결과로 
        // 데이터들이 한 곳에 모이는 문제가(이를 클러스터(Cluster)라고 함) 발생할 가능성도 높음

        // * 자릿수 접기의 한계
        // : 해시 함수가 서로 다른 입력 값에 대해 동일한 해시 테이블 주소를 반환하는 것
        // : 알고리즘이 아무리 정교하게 설계되었다 하더라도 모든 입력 값에 대해 고유한 해시 값을 만들지는 못함
        // -> 해시 함수의 충돌은 피할 수 없음

        // * 충돌해결방안

        // 1. 체이닝(Chaining) -> 오픈 해싱 기법인 동시에 폐쇄 주소법
        // 해시 함수가 서로 다른 키에 대해 같은 주소값을 반환해서 충돌이 발생하면 각 데이터를 해당 주소에 있는
        // 링크드 리스트에 삽입하여 문제를 해결하는 기법
        // -> 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
        // * 장점
        // : 해시테이블에 자료가 많아지더라도 성능저하가 적음
        // * 단점
        // : 원하는 데이터를 찾기 위해 순차 탐색을 해야 하는 링크드 리스트의 단점을 고스란히 가짐
        // : 해시테이블 외 추가적인 저장공간이 필요 -> 노드

        // 2. 개방주소법(Open Addressing)  -> C#에서 사용함
        // : 충돌이 일어날 때 해시 함수에 의해 얻어진 주소가 아니더라도 얼마든지 다른 주소를 사용할 수 있도록 
        // 허용하는 충돌 해결 알고리즘
        // -> 해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식
        // 해시 충돌 시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정

        // * 선형 탐색(Linear Probing)
        // : 가장 간단한 탐사 방법
        // : 해시 함수로부터 얻어낸 주소에 이미 다른 데이터가 입력되어 있음을 발견하면,
        // 현재 주소에서 고정 폭으로 다음 주소로 이동
        // -> 그 주소에도 다른 데이터가 있어 충돌이 발생하면 또 그 다음 주소로 이동
        // 하면서 비어있는 주소를 찾아내면 그곳에 데이터를 입력함
        // : 해시 테이블에 삽입된 데이터들이 서로 모여 있는 클러스터 현상이 발행하면 탐색 시간이
        // 길어지면서 해시테이블의 성능이 엄청나게 저하됨

        // 해당 문제를 개선한 알고리즘이 제곱 탐색임

        // * 제곱 탐색(Quadratic Probing)
        // : 선형 탐색과 비슷한 개념이나,
        // : 선형 탐색에서 다음 주소를 찾기 위해 고정폭만큼 이동하는 것에 비해
        // 제곱 탐색은 이동폭이 제곱수로 늘어남
        // : 제곱 탐색은 충돌이 일어났을 때 제곱수의 폭으로 이동함
        // : 한 주소에서 충돌이 발생하면 탐사할 위치가 정해져 있기 때문에 선형 탐색과 다른 클러스터가 발생함
        // : 서로 다른 해시 값을 갖는 데이터에 대해서는 클러스터가 형성되지 않도록 하는 효과가 어느정도
        // 있지만, 같은 해시 값을 갖는 데이터에 대해서는 2차 클러스터를 형성하도록 유도하는 문제가 있음

        // 1차 클러스터와 2차 클러스터를 한 번에 해결하는 방법이 이중 해시임

        // * 이중 해시(Double Hashing)
        // : 선형 탐색과 제곱 탐색에서 발생하는 클러스터를 제대로 방지할 수 있는 방법은
        // 탐사할 주소의 규칙성을 없애버리는 것임
        // : 해시 함수에 키를 입력하여 얻어낸 주소에서 충돌이 일어나면 새로운 주소를 찾아서 이동해야하는데,
        // 이 때의 이동폭을 제 2의 해시 함수로 계산
        // -> 1개의 해시 함수는 최초의 주소를 얻을 때 사용,
        // -> 또 다른 해시 함수는 충돌이 일어났을 떄 탐사 이동폭을 얻기 위해서 사용
        // 하여 탐색 이동폭의 규칙성을 없애면서 같은 키에 대해서는 항상 같은 결과는 얻을 수 있음
        // : 아무리 성능이 뛰어난 충돌 해결 알고리즘도 해시 테이블의 여유 공간이 모두 차버리면
        // 성능 저하가 발생함 

        // * 장점
        // : 추가적인 저장공간이 필요하지 않음, 삽입삭제 시 오버헤드가 적음
        // * 단점
        // : 해시테이블에 자료가 많아질수록 성능저하가 많음
        // 해시테이블의 공간 사용률이 높을 경우 성능저하가 발생하므로 재해싱 과정을 진행함
        // * 재해싱
        // : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱해서 제자리로 넣어줌

        static void Main(string[] args)
        {
            
        }
    }
}